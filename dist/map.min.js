/**
 * map-polyfill - A Map polyfill written in TypeScript, unit tested using Jasmine and Karma.
 *
 * @author Brenden Palmer
 * @version v0.0.1-alpha.2
 * @license MIT
 */
;(function() {
"use strict";

var es6map;
(function (es6map) {
    var MapIterator = (function () {
        function MapIterator(map, type) {
            this.index = 0;
            this.map = null;
            this.done = false;
            this.map = map;
            this.type = type;
        }
        MapIterator.prototype.next = function () {
            var _value;
            if (this.map.keyArray.length > this.index) {
                if (this.type === 'entries') {
                    _value = [this.map.keyArray[this.index], this.map.get(this.map.keyArray[this.index])];
                }
                else if (this.type === 'keys') {
                    _value = this.map.keyArray[this.index];
                }
                else if (this.type === 'values') {
                    _value = this.map.get(this.map.keyArray[this.index]);
                }
                this.index++;
            }
            else {
                this.done = true;
            }
            return {
                value: _value,
                done: this.done
            };
        };
        return MapIterator;
    })();
    es6map.MapIterator = MapIterator;
})(es6map || (es6map = {}));
var es6map;
(function (es6map) {
    var MapConstants = (function () {
        function MapConstants() {
        }
        Object.defineProperty(MapConstants, "MAP_KEY_IDENTIFIER", {
            get: function () {
                return 'MAP_KEY_IDENTIFIER_OZAbzyeCu3_spF91dwX14';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapConstants, "MAP_SET_THROWABLE_MESSAGE", {
            get: function () {
                return 'Invalid value used as map key';
            },
            enumerable: true,
            configurable: true
        });
        return MapConstants;
    })();
    es6map.MapConstants = MapConstants;
})(es6map || (es6map = {}));
var es6map;
(function (es6map) {
    var MapSequencer = (function () {
        function MapSequencer() {
            if (MapSequencer.instance !== null) {
                throw 'Get the instance of the MapSequencer using the getInstance method.';
            }
            this.identifier = 0;
        }
        MapSequencer.getInstance = function () {
            if (MapSequencer.instance === null) {
                MapSequencer.instance = new MapSequencer();
            }
            return MapSequencer.instance;
        };
        MapSequencer.prototype.next = function () {
            return 'Map_CJPOYUrpwK_aHBtMHXsTM' + String(this.identifier++);
        };
        MapSequencer.instance = null;
        return MapSequencer;
    })();
    es6map.MapSequencer = MapSequencer;
})(es6map || (es6map = {}));
var es6map;
(function (es6map) {
    var MapUtils = (function () {
        function MapUtils() {
        }
        MapUtils.defineProperty = function (object) {
            var _value;
            if (MapUtils.isValidObject(object) === false) {
                throw new TypeError(es6map.MapConstants.MAP_SET_THROWABLE_MESSAGE);
            }
            if (typeof object[es6map.MapConstants.MAP_KEY_IDENTIFIER] === 'undefined') {
                _value = es6map.MapSequencer.getInstance().next();
                try {
                    Object.defineProperty(object, es6map.MapConstants.MAP_KEY_IDENTIFIER, {
                        enumerable: false,
                        configurable: false,
                        get: function () {
                            return _value;
                        }
                    });
                }
                catch (e) {
                    throw new TypeError(es6map.MapConstants.MAP_SET_THROWABLE_MESSAGE);
                }
            }
            else {
                _value = object[es6map.MapConstants.MAP_KEY_IDENTIFIER];
            }
            return _value;
        };
        MapUtils.getProperty = function (object) {
            if (MapUtils.isValidObject(object) === true) {
                return object[es6map.MapConstants.MAP_KEY_IDENTIFIER];
            }
            else {
                return void 0;
            }
        };
        MapUtils.isValidObject = function (object) {
            return object === Object(object);
        };
        return MapUtils;
    })();
    es6map.MapUtils = MapUtils;
})(es6map || (es6map = {}));
var es6map;
(function (es6map) {
    var Map = (function () {
        function Map(iterable) {
            if (iterable === void 0) { iterable = []; }
            this.map = {};
            this.keyArray = [];
            for (var _i = 0; _i < iterable.length; _i++) {
                var keyValue = iterable[_i];
                if (keyValue && keyValue.length >= 2) {
                    this.set(keyValue[0], keyValue[1]);
                }
            }
        }
        Map.prototype.get = function (key) {
            if (this.has(key) === true) {
                var _value = es6map.MapUtils.getProperty(key);
                if (_value === void 0) {
                    _value = String(key);
                }
                return this.map[_value];
            }
            else {
                return void 0;
            }
        };
        Map.prototype.has = function (key) {
            var _value = es6map.MapUtils.getProperty(key);
            if (_value === void 0) {
                _value = String(key);
            }
            return _value !== void 0 && typeof this.map[_value] !== 'undefined';
        };
        Map.prototype.delete = function (key) {
            if (this.has(key) === true) {
                var _value = es6map.MapUtils.getProperty(key);
                if (_value === void 0) {
                    _value = String(key);
                }
                this.keyArray.splice(this.keyArray.indexOf(key), 1);
                delete this.map[_value];
                return true;
            }
            else {
                return false;
            }
        };
        Map.prototype.set = function (key, value) {
            this.delete(key);
            var _key;
            try {
                _key = String(es6map.MapUtils.defineProperty(key));
            }
            catch (e) {
                _key = String(key);
            }
            this.keyArray.push(key);
            this.map[_key] = value;
        };
        Map.prototype.entries = function () {
            return new es6map.MapIterator(this, 'entries');
        };
        Map.prototype.keys = function () {
            return new es6map.MapIterator(this, 'keys');
        };
        Map.prototype.values = function () {
            return new es6map.MapIterator(this, 'values');
        };
        Map.prototype.forEach = function (callback, thisArg) {
            for (var _i = 0, _a = this.keyArray; _i < _a.length; _i++) {
                var key = _a[_i];
                if (thisArg) {
                    callback.call(thisArg, this.get(key), key, this);
                }
                else {
                    callback(this.get(key), key, this);
                }
            }
        };
        Map.prototype.clear = function () { };
        return Map;
    })();
    es6map.Map = Map;
})(es6map || (es6map = {}));
var es6map;
(function (es6map) {
    if (!window.Map) {
        window.Map = es6map.Map;
    }
})(es6map || (es6map = {}));
}());
